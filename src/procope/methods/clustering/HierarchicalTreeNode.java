/*
 * This file is part of ProCope
 *
 * ProCope is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ProCope is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ProCope.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2008, Teaching and Research Unit Bioinformatics, LMU Munich
 * http://www.bio.ifi.lmu.de/Complexes/ProCope/
 *
 */
package procope.methods.clustering;

import java.util.ArrayList;
import java.util.Collection;

import procope.data.complexes.ComplexSet;


/**
 * Represents one node of the tree generated by 
 * {@link HierarchicalClusteringTrees hierarchical agglomerative clustering}.
 * This tree is constructed bottom up and represents the order of 
 * agglomerations performed during the clustering. Similarities in the tree
 * are monotonically decreasing from the leaf to the root. A cutoff can be
 * applied on this tree to cut it at a given level of similarity and derive
 * a clustering from the tree.
 * 
 * <p>This class only contains one public method to derive a complex set from
 * the root tree node returned by clustering method.
 * 
 * @author Jan Krumsiek
 */

public class HierarchicalTreeNode {
	
	/**
	 * Similarity at which the children of this node were merged
	 */
	protected float similarity;
	
	/**
	 * List of children for this tree node. Should always contain two items
	 * as hierarchical agglomerative clustering create binary trees.
	 */
	protected Collection<HierarchicalTreeNode> children;

	/**
	 * Contains the item associated with this node if this is a leaf node
	 * or -1 if this is an inner node
	 */
	protected int label;
	
	/**
	 * Constructor which takes an item identifier but no similarity 
	 * (for the leaf nodes)
	 */
	protected HierarchicalTreeNode(int label) {
		this(label, 0f);
	}
	
	/**
	 * Constructor which takes an item and a merging similarity
	 */
	protected HierarchicalTreeNode(int label, float similarity) {
		// initialize children list
		this.children = new ArrayList<HierarchicalTreeNode>();
		// store label
		this.label = label;
		this.similarity = similarity;
	}
	
	/**
	 * add a child to this node
	 */
	protected void addChild(HierarchicalTreeNode child) {
		children.add(child);
	}
	
	/**
	 * Extracts a clustering from this tree by cutting it a given similarity
	 * threshold value.
	 * 
	 * @param threshold cutoff similarity value
	 * @return resulting clustering
	 */
	public ComplexSet extractClustering(float threshold) {
		// initialize builder
		ArrayList<ArrayList<Integer>> complexBuilder = new ArrayList<ArrayList<Integer>>();
		recFindCuts(threshold, complexBuilder);
		return new ComplexSet(complexBuilder);
	}
	
	/**
	 * get all complexes in this subtree (recursive method)
	 */
	private void accumulateClusterBelow(ArrayList<Integer> accumulator) {
		if (children.size() == 0) 
			// leaf
			accumulator.add(label);
		else {
			// recursively call children
			for (HierarchicalTreeNode child : children)
				child.accumulateClusterBelow(accumulator);
		}
	}
	
	/**
	 * find nodes below which we will cut
	 */
	private void recFindCuts(float threshold, ArrayList<ArrayList<Integer>> complexBuilder) {
		// current cluster similarty above threshold
		if (this.similarity >= threshold) {
			// add all leafs as new cluster
			ArrayList<Integer> newCluster = new ArrayList<Integer>();
			accumulateClusterBelow(newCluster);
			complexBuilder.add(newCluster);
		} else {
			// if this is a leaf => add as singleton cluster
			if (children.size() == 0) {
				complexBuilder.add(singleton(label));
			} else {
				// go deeper
				for (HierarchicalTreeNode child : children)
					child.recFindCuts(threshold, complexBuilder);
			}
		}
		
	}
	
	/**
	 * create a singleton cluster
	 */
	private ArrayList<Integer> singleton(int prot) {
		ArrayList<Integer> single = new ArrayList<Integer>();
		single.add(prot);
		return single;
	}

	
}
